# 💢팀구 프로젝트에서 로그인 부분을 구현하면서 했던 고민들

---

가장 먼저 저희는 JWT 토큰 기반 인증을 사용하기로 결정 하였습니다.

때문에 JWT 토큰에 대해서 알아보고 시작하겠습니다.

---

## JWT

토큰 기반 인증이 왜 등장하였고 중요한지 이해하기 위해서는 과거에 사용해왔던 서버 기반 인증 시스템을 확인해볼 필요가 있습니다.

![session](../assets/img/session.png)

과거에 사용되었던 인증 시스템에서는 유저들의 정보를 서버측(세션)에서 기억하고 있었습니다. 보통 로그인한 유저에 대한 세션을 만들고 이를 메모리/디스크/데이터베이스 시스템에 저장해두는 방식이었습니다.

이러한 서버 기반 인증은 분명한 한계를 가집니다.

- 세션

  > 유저가 인증을 할 때, 서버는 이 기록을 서버에 저장해야합니다. 해당 기록을 우리는 **세션**이라고 부릅니다. 대부분의 경우에 세션을 메모리에 저장하게되는데, 만약 로그인 중인 유저의 수가 기하급수적으로 늘어난다면 어떻게 될까요? 그럴 경우 서버의 램이 과부화 될 것입니다. 이를 피하기 위해서, 세션을 데이터베이스에 저장하는 방식도 있지만, 이 또한 유저의 수가 많으면 데이터베이스의 성능에 무리를 줄 수 있습니다.

- 확장성

  > 세션을 사용하면 서버를 확장하는 일 또한 어려워집니다. 여기서 서버의 확장이란, 단순히 서버의 사양을 업그레이드 하는것이 아니라, 더 많은 트래픽을 감당하기 위하여 여러개의 프로세스를 돌리거나, 여러대의 서버 컴퓨터를 추가 하는것을 의미합니다. 세션을 사용하면서 분산된 시스템을 설계하는건 불가능한것은 아니지만 과정이 매우 복잡해집니다.

- CORS

  > 웹 어플리케이션에서 세션을 관리 할 때 자주 사용되는 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계되어있습니다. 따라서 쿠키를 여러 도메인에서 관리하는것은 좀 번거롭습니다.



이러한 세션의 단점들 때문에 토큰의 개념이 등장하였습니다.

토큰 기반 시스템은 **stateless** 합니다. 무상태, 즉 상태유지를 하지 않는 것이죠. 이 시스템에서는 더 이상 유저의 인증 정보를 서버나 세션에 담아두지 않습니다. 이 특징 하나만으로 위에서 언급된 세션의 단점들의 대부분이 해소됩니다.

또한, 세션이 존재하지 않으니, 유저들이 로그인 되어 있는지, 안 되어 있는지 신경쓰지 않습니다. 이 덕분에 서버를 손쉽게 확장할 수 있습니다.

토큰 기반 시스템의 구현 방식은 크게 다음과 같습니다.

![token_goin](../assets/img/token_goin.png)

1. 유저가 아이디와 비밀번호로 로그인을 한다.
2. 서버측에서 해당 계정정보를 검증한다.
3. 계정 정보가 정확하다면, 서버측에서 accessToken을 발급해준다.
4. 클라이언트 측에서는 전달받은 토큰을 저장해두고, 서버에 요청을 할 때 마다, 해당 토큰을 함께 서버에 전달한다.
5. 서버는 토큰을 검중하고 요청에 응답한다.

그렇다면 토큰 기반 시스템의 장점은 정확히 어떤 것들이 있을까요?

- 무상태이며 확장성이 있다

  >  토큰은 클라이언트에 저장하기 때문에 완전히 stateless 하며, 서버를 확장하기에 매우 적합한 환경을 제공합니다. 만약에 세션을 서버측에 저장하고 있고, 서버를 여러대를 사용하여 요청을 분산하였다면, 어떤 유저가 로그인 했을땐, 그 유저는 처음 로그인했었던 그 서버에만 요청을 보내도록 설정을 해야합니다. 하지만, 토큰을 사용한다면, 어떤 서버로 요청이 들어가던, 이제 상관이 없죠.

- 확장성

  > 여기서의 확장성은, Scalability 와는 또 다른 개념입니다. Scalability 는 서버를 확장하는걸 의미하는 반면, **Extensibility** 는 로그인 정보가 사용되는 분야를 확장하는것을 의미합니다. 토큰을 사용하여 다른 서비스에서도 권한을 공유 할 수 있습니다. 예를 들어서, 스타트업 구인구직 웹서비스인 [로켓펀치](https://www.rocketpunch.com/jobs?specialty=react)에서는 Facebook, LinkedIn, GitHub, Google 계정으로 로그인을 할 수 있습니다. 토큰 기반 시스템에서는, 토큰에 선택적인 권한만 부여하여 발급을 할 수 있습니다 (예를들어서 로켓펀치에서 페이스북 계정으로 로그인을 했다면, 프로필 정보를 가져오는 권한은 있어도, 포스트를 작성 할 수 있는 권한은 없죠)
  
- 여러 플랫폼 및 도메인
  
  > 서버 기반 인증 시스템의 문제점을 다룰 때 CORS 에 대하여 언급 했었죠? 어플리케이션과 서비스의 규모가 커지면, 우리는 여러 디바이스를 호환 시키고, 더 많은 종류의 서비스를 제공하게 됩니다. 토큰을 사용한다면, 그 어떤 디바이스에서도, 그 어떤 도메인에서도, 토큰만 유효하다면 요청이 정상적으로 처리 됩니다. 서버측에서 어플리케이션의 응답부분에 다음 헤더만 포함시켜주면 되지요. `Access-Control-Allow-Origin: *` 이런 구조라면, assets 파일들(이미지, css, js, html 파일 등)은 모두 CDN 에서 제공을 하도록 하고, 서버측에서는 오직 API만 다루도록 하도록 설계 할 수도 있지요.

---

하지만, 이러한 토큰 또한 분명한 단점이 존재하는데 보안성이 약한 클라이언트에 저장되는 데이터라는 점과 해당 토큰만 가지고 있으면 실제 사용자와 동등한 위치를 가질 수 있다는 점이다.

이 때문에, 우리는 토큰에 만료기한을 두어서 일정시간이 지나면 더이상 해당 토큰을 제 기능을 할 수 없도록 막는다.

하지만! 이것 또한 문제가 있는데 해커가 가지고 있는 토큰만 만료되는 것이 아니라, 사용자가 가지고 있는 토큰 또한 만료된다는 것이다.

때문에 리프레시 토큰이라는 개념을 사용하게 된다.

대략적인 플로우는 다음과 같다. (첫로그인부터 시작한다는 가정)

(여기에도 그림이 있어야겠다)

1. 브라우저는 사용자로부터 아이디와 비밀번호를 받아 서버에 보낸다.
2. 서버는 해당 아이디와 비밀번호가 유효한지 확인하기 위해 데이터베이스에 해당 정보를 보낸다.
3. 데이터베이스에서는 서버의 요청을 확인하고 다시 서버에 응답을 준다.
4. 서버는 데이터베이스에서 해당 데이터가 유효하다고 판단하게 되면 accessToken과 refreshToken 이 두 종류의 토큰을 만든다. accessToken의 경우 저장하지 않지만 refreshToken의 경우에는 저장한다. (어디에 저장하는걸까?) 그리고 클라이언트에 두 종류의 토큰을 보낸다.
5. 클라이언트는 쿠키 혹은 스토리지에 두 종류의 토큰 모두를 저장해둔다.
6. 이후 서버에 대한 모든 요청의 헤더에 accessToken을 붙여서 보낸다.
7. accessToken의 유효기한이 지난다......
8. 클라이언트는 다시 서버에 요청을 보낸다. 당연히 헤더에는 accessToken을 붙이고 이 토큰은 만료되었다.
9. 서버에서는 해당 accessToken이 만료된 것을 파악하고, 이에 대한 응답을 해준다.
10. 클라이언트는 해당 응답을 받고, 자신의 accessToken이 만료되었음을 인지한다. 그리고 바로 가지고 있던 refreshToken을 서버에 보낸다. 
11. 서버는 refreshToken을 확인하고 새롭게 accessToken을 발급하여 보내준다.

12. 만약? refreshToken 또한 만료된 상황이라면 재로그인 시킬 필요가 있다.

---

### 그렇다면 accessToken이 만료되었음을 인지하고, refreshToken을 보내는 플로우는 클라이언트측에서 어떻게 처리할 수 있을까?

(여기 그림을 그려서 넣으면 좋겠다.)

해당 부분에서 바로 axios의 interceptor 기능을 사용한다.

> fetch와 구분되는 axios의 차이점으로써, axios의 장점 중 하나다. 이런 케이스에 사용하는건지는 해당 프로젝트를 진행하면서 처음 알았다.

axios의 interceptor 기능을 사용하면 `then`이나 `catch`로 처리되기 전에 요청(request)이나 응답(response)을 가로채 어떠한 작업을 수행할 수 있게 된다. 

실제 팀구에서는 해당 부분을 구현하지 않았기 때문에 필요할 때 `axios interceptor refresh token` 키워드로 검색해서 찾아보고 활용하면 좋을 듯 싶다.

---

### axios의 interceptor의 또 다른 장점

https://github.com/axios/axios/issues/450

해당 이슈의 내용을 보게 되면 axios의 interceptor라는 기능이 왜 장점인지 다시 한 번 확인 할 수 있다. 

만약, accessToken이 만료된 사용자가 악의적으로 무수히 많은 요청을 서버에 보낸다고 가정해보자. 그렇게 되면 매 요청마다 리프레시 토큰이 만들어지고 저장되고 반환되는 작업이 반복될 것이다. 이는 서버에 굉장한 부하를 만들게 된다.

때문에, 클라이언트에서 똑같은 요청이 짧은 시간 안에 반복된다면 모든 요청은 무시하고 딱 하나만을 서버에 보내줄 필요가 있다. 이때 axios의 interceptor를 활용하면 해당 기능을 간단히 구현해낼 수 있다. (해당 이슈에 코드가 있다.)

---

## 아직 의문인 지점들

1. jwt 토큰을 활용하면서 어떻게 중복로그인을 막을 수 있느냐?

   > jwt 토큰의 stateless한 특성 탓에 중복 로그인을 막을 수 없다. 그렇다고 해당 사용자의 로그인 유무를 확인하기 위해 해당 데이터를 어딘가 저장하게 된다면 그 순간부터 jwt의 가장 큰 장점인 stateless한 특성이 사실상 사라지게 된다. 
   >
   > 또 다른 관점도 있었는데 꼭 중복로그인을 막아야 하는가? 넷플릭스 인프런 같이 아이디별로 권한이 확실히 다르고 기업의 이윤에 직접적인 연관이 되는 사이트 말고는 굳이 막지 않아도 되지 않을까?

2. refreshToken에 대한 탈취는 어떻게 막을 것이냐?

   > 토큰이 탈취되었을 때 보안적으로 위험하기 때문에 만료기한을 두는 것이고 이 만료기한 때문에 사용자가 불편할 수 있으니 리프레시 토큰을 두는 것이다.
   >
   > 그렇다면 리프레시 토큰이 탈취되는 경우는 어떨까? 
   >
   > 먼저, 실제 해커들이 데이터를 가져가는 대상은 보통 클라이언트나 서버가 아니라 그 사이에서 발생하는 HTTP 통신이라고 한다.   HTTP 통신에서 리프레시 토큰을 사용하는 경우는 accessToken이 만료되었을 경우 하나 뿐이기 때문에 상대적으로 조금 더 보안의 문제로부터 자유로울 수 있다.
   >
   > 하지만, 어쨋든 리프레시 토큰 또한 분명히 탈취될 수 있는 대상이며 리프레시 토큰이 탈취되는 순간 굉장히 큰 문제들이 발생하게 된다. 또한 보통 리프레시 토큰은 만료기한도 상대적으로 더 길기 때문에 더 큰 문제가 된다.
   >
   > https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/
   >
   > 해당 글에서 리프레시 토큰을 안전하게 가지고 있는 법에 대해서 정리해주었는데 이 글을 좀 천천히 읽어보고 정리할 필요가 있다.

3. refreshToken은 과연 좋은 것인가?

   > 위에서 설명했듯이 refreshToken은 결국에 어딘가 저장되어야 한다. 그렇다는 것은 결국 토큰의 가장 큰 특징인 stateless가 무의미해진다는 것이다. 

---

## 참고자료

https://velopert.com/2350

https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies



