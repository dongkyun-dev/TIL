# ✨동기와 비동기, Blocking과 NonBlocking

> 동기와 비동기 개념은 자바스크립트에 있어서 굉장히 중요하고, 이해하기 어려운 요소이다. 
>
> http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/
>
> 대부분의 개념과 자료를 해당 블로그에서 가져왔습니다.
>
> 정말 좋은 글과 설명 감사합니다.

---

## 동기

- Synchronous, 말 그대로 동시에 일어난다는 뜻이다. 이 동시에 일어난다는 말이 좀 헷갈릴 수 있는데, 여러 코드가 동시에 실행된다는 의미가 아니다. 바로, 요청과 결과가 동시에 일어난다는 의미이다. 요청을 하게 되면 시간이 얼마가 걸리는지와는 상관없이 결과가 올 때 까지 기다려야 한다.
- 설계가 매우 간단하고 직관적이지만, 결과가 주어질 때까지 아무 것도 하지 못하고 기다려야 한다는 단점이 있다. 실제 cpu가 느려지는 것은 아니지만, 시스템의 전체적인 효율이 저하된다. (나 또한 코드를 보고 이해할 때, 기본적으로 동기적인 관점에서 바라본다. 아마 대부분의 사람들이 그럴 것이다.)

## 비동기

- Asynchronous, 말 그대로 동시에 일어나지 않는다는 의미이다. 요청과 결과가 동시에 일어나지 않는다는 것이다. 
- 요청을 보낸 후 결과가 오기를 기다리지 않기 때문에 그 시간 동안 다른 작업을 수행하면서 자원을 효율적으로 사용할 수 있다는 장점이 있다.
- 요청을 받은 함수는 처리가 끝나면 요청을 한 함수를 호출하여 처리 결과를 반환한다. 이러한 함수 호출의 흐름이 사용자가 아닌, 일을 마친 시스템이 호출하는 형태이기 때문에 `콜백`이라고 부른다.

```javascript
// 콜백 함수를 사용하기 위한 선언
function add(x, callback) {
    let sum = x + x;
    console.log(sum);
    callback(sum);
}

// 콜백 함수의 호출
add(2, function(result) {
    add(result, function(result) {
        add(result, function(result) {
            console.log('finish!!');
        })
    })
})

// 결과값. 요청을 받은 함수의 처리가 끝나고 나서 콜백 함수가 호출되기 때문에 이런 식의 결
// 과가 나온다. 만약, 비동기면서 콜백함수를 사용하지 않았다면 계속 4만 나온다.
// 물론, 지금 위와 같은 코드의 형태는 좋은 코드가 아니며 저런 코드를 콜백 지옥(Callback 
// Hell)이라 한다. promise 혹은 async/await을 사용하는 더 좋은 코드들이 있다.
<output>
4
8
16
finish!!
```

---

블록킹과 동기가 비슷하고, 논블록킹과 비동기가 비슷하지만, 동기와 비동기, 블록킹과 논블록킹 이 두 개의 그룹은 서로 관심사가 다르다.

### Blocking/NonBlocking

> 블록킹/논블록킹의 관심사는 호출되는 함수가 바로 리턴하느냐 마느냐이다.

호출된 함수가 바로 리턴해서 호출한 함수에게 제어권을 넘겨주고, 호출한 함수가 다른 일을 할 수 있는 기회를 줄 수 있으면 논블록킹이다.

그렇지 않고 호출된 함수가 자신의 작업을 모두 마칠 때까지 호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만든다면 블록킹이다.



### Synchronouns/Asynchronous

> 동기/비동기는 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐에 관심이 있다.

호출되는 함수에게 callback을 전달해서, 호출되는 함수의 작업이 완료되면 호출되는 함수가 전달받은 callback을 실행하고, 호출하는 함수는 작업 완료 여부를 신경쓰지 않으면 비동기이다.

호출하는 함수가 호출되는 함수의 작업 완료 후 리턴을 기다리거나, 또는 호출되는 함수로부터 바로 리턴 받더라도 작업 완료 여부를 호출하는 함수 스스로 계속 확인하며 신경쓰면 동기이다.

---

### 결론

때문에 동기/비동기와 블록킹/논블록킹은 기본적으로 관심을 가지는 대상이 분명하게 다르다. 떄문에 동기 === 블록킹, 비동기 === 논블록킹 이라는 표현은 잘못된 표현이다.

더 나아가 서로 다른 개념이기 때문에 교차해서 개념을 적용하는 것 또한 가능하다. 즉, 동기이면서 논블록킹이 가능하고 비동기이면서 블록킹이 가능하다. 

해당 개념에 대한 자세한 예시와 설명은 해당 글을 쓰면서 참고한 블로그에 너무나도 잘 설명되어 있어서 그곳의 글을 읽어보는 것이 가장 좋을 것 같다. (최상단에 링크를 두었습니다.)

성능과 자원의 효율적 사용 관점에서 가장 유리한 모델은 **비동기-논블록킹** 모델이다.

---

## @참고문헌

https://velog.io/@minidoo/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98Callback-Function

https://joshua1988.github.io/web-development/javascript/javascript-asynchronous-operation/

https://jieun0113.tistory.com/73

https://private.tistory.com/24

http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/