# JITC

> https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/
>
> 해당 글을 해석하고, 약간의 살을 붙여 정리합니다.

---

JIT 컴파일을 이해하기 위해서는 인터프리터와 컴파일의 차이를 인지해야 한다.

인터프리터

- 한 줄씩 해석하고 실행하고를 반복한다.
- 전체를 해석하는 것이 아닌, 한 줄씩 해석하고 실행하기 때문에 실행의 시작 시점이 컴파일러에 비해 빠르다는 장점을 가진다.
- 이러한 장점은 최대한 사용자에게 빠른 인터랙티브 전달해야하는 자바스크립트의 목적과 동일하다. 때문에 초기 브라우저들은 자바스크립트 인터프리터를 사용했다.
- 하지만, 한 줄 씩 해석한다는 특징 때문에 똑같은 코드가 오더라도 해석하는 과정을 다시 반복하게 된다. (루프문이라면 이 똑같은 코드에 대한 해석을 계속 반복할 것이다.)

컴파일러

- 한번에 전체를 해석하고, 한 번에 전체를 실행한다.
- 이러한 특징 때문에 실행의 시작 시점이 늦다.
- 하지만, 한번에 전체를 해석하기 때문에 어떠한 코드가 반복되는지 사전에 파악이 가능하고 이를 활용해 똑같은 코드를 다시 해석하지 않는다.
- 또한, 런타임에 해석과 실행을 수행하는 인터프리터와는 달리, 컴파일러는 런타임 이전에 컴파일 타임이 존재하고 이 시간에 코드에 대한 해석이 이루어진다. 즉, 코드를 실행시키기 이전에 충분한 시간이 존재하고 이 시간을 활용하여 최적화를 할 수 있다는 장점을 가진다.

**모든 기술들이 그렇듯 이 두 개 중 반드시 하나를 선택할 필요는 존재하지 않는다. 자신의 상황에 따라 더 유리한 것을 선택하면 되고 이를 위해서 나온 것이 Just-In-Time Compiler이다.**

---

### JITC

> 브라우저마다 약간의 차이는 존재하지만, 기본적인 아이디어는 동일하다.

자바스크립트 엔진에는 모니터(aka. profiler)라는 개념이 존재한다. 이 모니터는 코드의 실행을 지켜보면서 몇번 실행되었는지, 어떠한 타입이 쓰였는지를 기록한다.

가장 처음 코드가 실행되면 모니터는 전부 인터프리터를 활용하여 처리한다. 만약 똑같은 내용의 코드가 여러번 반복된다면 해당 부분을 **warm**, 굉장히 많이 반복된다면 **hot**으로 기록해둔다. 

---

### Baseline compiler (Baseline JITC)

특정 코드 부분이 **warm** 상태가 되면, 모니터는 해당 부분을 Baseline JITC에 던지고, Baseline JITC는 해당 부분을 컴파일하고 그 결과를 저장합니다.

**warm** 상태가 된 코드는 stub이라는 형태로 컴파일 되는데, stub은 행번호와 변수의 타입으로 인덱싱 됩니다. 모니터는 코드를 실행하다, 같은 타입을 가진 같은 코드가 지속적으로 반복되는 것을 파악하면 컴파일 후 저장된 결과를 가져와서 사용하게 됩니다.

Baseline compiler는 이뿐 아니라 추가적인 최적화를 통해 코드의 실행속도를 개선합니다.

---

### Optimizing compiler (Optimizing JITC)

특정 코드 부분이 **hot** 상태가 되면, 모니터는 해당 부분을 Optimizing JITC에 던지고, Optimizing JITC는 Baseline JITC에서 만든 결과물과는 다르면서도 더 빠른 결과물을 만들어내고 이를 저장합니다.

하지만, Optimizing JITC에서 더 빠른 결과물을 만들어내기 위해서는 몇가지의 가정들이 필요합니다. 예를 보겠습니다.

```javascript
function arraySum(arr) {
	let sum = 0;
	for (let i = 0; i < arr.length; i++) {
		sum += arr[i];
	}
}
```

해당 코드가 존재하고 이 코드의 arr라는 파라미터에는 계속해서 int값만이 들어왔다고 가정합니다. 그렇다면 모니터는 지금까지의 과정을 바탕으로 해당 함수의 파라미터로는 계속해서 int가 들어올 것이라는 가정하에 결과물을 만들고 저장합니다.

하지만, 이러한 가정은 결국 가정일 뿐입니다. 동적 타입이라는 특징을 가지는 자바스크립트에서 이러한 가정이 항상 참일 수는 없습니다. 때문에 Optimizing JITC에 의해 컴파일되고 저장된 코드는 실제로 사용되기 전에 해당 가정이 유효한지에 대한 검사를 수행하게 됩니다. 가정이 참이라면 해당 컴파일된 결과물을 그대로 사용하고, 가정이 거짓이라면 JITC는 해당 컴파일된 결과물의 가정에 오류가 있다고 판단하고 컴파일된 결과물을 버리게 됩니다. 그리고 다시 인터프리터 단계 혹은 Baseline JITC로 돌아갑니다. 이러한 과정을 **deoptimization** 혹은 **bailling out**이라고 합니다.

이러한 deoptimization이 반복되면 더 빠른 실행을 위해 활용했던 Optimizing JITC는 오히려 독이 됩니다. 때문에 대부분의 브라우저들에서는 optimization과 deoptimization 사이클이 10회 이상 반복되면 해당 부분에 대한 optimizing은 더이상 수행하지 않습니다.

---

### 결론

- 반복되는 코드부분이 별로 없다면 인터프리터의 효율이 JITC보다 좋다.
- 반복되는 코드부분이 많다면 반대이다.
- 자바스크립트는 이 두개의 장점 모두를 활용하기 위해 이 둘을 모두 사용한다.
- Optimizing JITC의 특징을 알았다면 하나의 배열에는 같은 타입만 넣어주도록 하자. 배열의 크기가 클 수록 특히 그래야한다!

---

### 참고문헌

https://meetup.toast.com/posts/77

https://pks2974.medium.com/v8-%EC%97%90%EC%84%9C-javascript-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EC%A0%95%EB%A6%AC%ED%95%B4%EB%B3%B4%EA%B8%B0-25837f61f551

이러한 최적화가 V8에서 어떻게 이루어지는지 더 자세하고 깊게 알고 싶다면 해당 글을 보면 좋을 것 같습니다.