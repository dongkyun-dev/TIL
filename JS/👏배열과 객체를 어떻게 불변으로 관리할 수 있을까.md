# ðŸ‘ë°°ì—´ê³¼ ê°ì²´ë¥¼ ì–´ë–»ê²Œ ë¶ˆë³€ìœ¼ë¡œ ê´€ë¦¬í•  ìˆ˜ ìžˆì„ê¹Œ?

---

function tranform their inputs to outputs.

function don't have side effects.

avoiding side effects is immutable data

immutable data meaning once we've created it, it never changes.

immutableí•˜ê²Œ ìœ ì§€í•˜ê¸° ìœ„í•´ì„œëŠ” we have to manage who's been changing what, when, who's been putting which data into array.

we have to have a lot of overhead to manage that state, and that gives us headaches.

ê·¸ë ‡ë‹¤ë©´ `arr = [1, 2, 3, 4, 5, 6, 7]` ê°€ ìžˆì„ ë•Œ ì´ arrì˜ ë‘ë²ˆì§¸ ìžë¦¬ë¥¼ 8ë¡œ ë°”ê¾¸ê³  ì‹¶ì„ ë•Œ ì–´ë–»ê²Œ í• ê±°ë‹ˆ???

ê·¸ëƒ¥ arr[2]ì— 8ì„ ë„£ì–´ë²„ë ¤?? ê·¸ëŸ¬ë©´ immutableì˜ ì›ì¹™ì„ í•´ì¹˜ëŠ” ê±°ë‹¤.

ê·¸ëŸ¬ë©´ ìƒˆë¡œìš´ arrayë¥¼ ë§Œë“¤ê³  arr[2] ì— ë¯¸ë¦¬ 8ì„ ë„£ì–´ë‘ê³  ë‚˜ë¨¸ì§€ ìžë¦¬ë¥¼ ë³µì‚¬í• ê¹Œ? êµ‰ìž¥í•œ ë¹„íš¨ìœ¨ì´ë‹¤. I had to allocate the space for that entire array, even all of the stuff that didn't change.

ì´ë ‡ê²Œ ë˜ë©´ ì‹œê°„ë„ ì˜¤ëž˜ ê±¸ë¦¬ê³  ë©”ëª¨ë¦¬ë„ ì—„ì²­ ìž¡ì•„ë¨¹ê² ì§€.

ì´ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìžˆëŠ”ê²Œ ë°”ë¡œ immutable data structure!



partially persistent data structure

> old versionì„ ë³¼ ìˆ˜ë„ ìžˆê³  access í•  ìˆ˜ë„ ìžˆì§€ë§Œ ê·¸ ê°’ì„ ë°”ê¾¸ì§€ëŠ” ëª»í•˜ëŠ” ê²ƒ. updateëŠ” í•­ìƒ most current versionì—ì„œë§Œ ì´ë£¨ì–´ì ¸ì•¼ í•œë‹¤.

fully persistent data structure

> old versionì„ ë³¼ ìˆ˜ë„ ìžˆê³ , accessë„ í•  ìˆ˜ ìžˆê³ , update ë˜í•œ ê°€ëŠ¥í•˜ë‹¤.

ìš°ë¦¬ê°€ ì´ì•¼ê¸°í•´ë³¼ ê²ƒì€ persistent immutable data structure

ì–´ë–»ê²Œ persistent í•˜ë©´ì„œë„ immutableí•œ ë°ì´í„° êµ¬ì¡°ë¥¼ ë§Œë“¤ ìˆ˜ ìžˆì„ê¹Œ? ì‹ ì—ê²Œ ë¹Œì–´ì•¼ í•˜ëŠ”ê±´ê°€?

ì•„ë‹ˆë‹¤. treesì™€ sharing ì´ ë‘ê°œì˜ conceptë¡œ íš¨ìœ¨ì ì¸ immutable dataë¥¼ ë§Œë“¤ ìˆ˜ê°€ ìžˆë‹¤.

ê¸°ì¡´ì— 1ì—´ë¡œ ë°°ì—´ì„ ë§Œë“¤ì–´ ë‘ê³  í¬ì¸í„°ë¡œ ê·¸ ë§¨ ì•žì„ í¬ì¸íŒ… í•˜ëŠ” ì‹ìœ¼ë¡œ ë°°ì—´ì„ ë§Œë“œëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ì´ì œëŠ” ë°°ì—´ì„ íŠ¸ë¦¬ì˜ êµ¬ì¡°ë¡œ ë§Œë“¤ê³  ë§¨ ìœ„ë¥¼ í¬ì¸íŒ… í•˜ëŠ” ì‹ì´ë‹¤.

(9:59 ì´ˆì— íŠ¸ë¦¬ëª¨ì–‘ì´ ë‚˜ì˜¨ë‹¤) ì—¬ê¸°ì„œ ë¶€í„° í•´ì‰¬ íŠ¸ë¼ì´ì— ëŒ€í•´ì„œ ë‹¤ì‹œ ê³µë¶€í•˜ê¸° ë‹¤ì‹œ ì •ë¦¬ ì‹œìž‘í•´ì•¼í•œë‹¤.

hash array mapped TRIE



ì´ ëª¨ë“ ê±¸ ìš°ë¦¬ê°€ êµ¬í˜„í•´ì„œ ì‚¬ìš©í•´ì•¼ í• ê¹Œ? ë‹¤í–‰ížˆë„ ì´ì— ëŒ€í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì¡´ìž¬í•œë‹¤.

1. mori    // ì¡°ê¸ˆ ë” ë°”ë‹ë¼ìžë°”ìŠ¤í¬ë¦½íŠ¸ë¥¼ ìœ„í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬
2. immutable.js

ì¼ë‹¨ ê¸°ë³¸ì ìœ¼ë¡œ ë‘˜ë‹¤ ë¶ˆë³€ ê°ì²´ì´ê¸° ë•Œë¬¸ì— ì²˜ìŒ ê°’ì´ ë°”ë€Œì§€ ì•ŠëŠ”ë‹¤. ê°’ì´ ë°”ë€Œì–´ì•¼ í•œë‹¤ë©´ ìƒˆë¡œìš´ê²Œ ë§Œë“¤ì–´ì§€ê³  ê·¸ ì•ˆì˜ ê°’ì´ ë‹¬ë¼ì§€ëŠ” ê±°ì§€.

```javascript
var mori = require('mori')

var a = mori.vector(1, 2)   // [1, 2]
var a2 = mori.conj(a, 3)	// [1, 2, 3]
mori.count(a) 			   // 2
mori.get(a2, 2)			   // 3

var o = mori.hashMap("a", 1, "b", 2)	// {"a" 1 "b" 2}
var o2 = mori.assoc(o, "a", 3)		   // {"a" 3 "b" 2}
mori.get(o, "a")					  // 1
mori.get(o2, "a")					  // 3
```

```javascript
var Imjs = require('immutable')

var a = Imjs.List.of(1, 2)	// [1, 2]
var a2 = a.push(3)		   // [1, 2, 3]
a.size 				      // 2
a2.get(2)				  // 3

var o = Imjs.Map({"a": 1, "b": 2})		// {"a": 1, "b": 2}
var o2 = o.set("a", 3)				   // {"a": 3, "b": 2}

o.get("a") 							// 1
o2.get("a")							// 3 
```

ë³´ë‹¤ì‹œí”¼ moriëŠ” ì¼ë°˜ ìžë°”ìŠ¤í¬ë¦½íŠ¸ì˜ ì‹ íƒìŠ¤ì™€ëŠ” êµ¬ì¡°ê°€ ë‹¤ë¥¸ ê²ƒì„ í™•ì¸í•  ìˆ˜ ìžˆë‹¤. ë°˜ë©´ immutable.jsëŠ” í›¨ì”¬ ë” ìžë°”ìŠ¤í¬ë¦½íŠ¸ ìŠ¤ëŸ½ë‹¤. ë•Œë¬¸ì— ì‹¤ì œ ë‚´ê°€ ì‚¬ìš©í•´ì•¼ í•œë‹¤ë©´ immutable.jsë¥¼ ì“°ì§€ ì•Šì„ê¹Œ... ìƒê°ì´ ë“ ë‹¤.

Mori

> ClosureScript port
>
> Functional API
>
> Faster

Immutable.js

> JS through & through
>
> Object oriented API
>
> A bit smaller





í‚¬ë§ ì§ˆë¬¸ì€

ìžë°”ìŠ¤í¬ë¦½íŠ¸ì˜ ì„±ëŠ¥ ê°œì„ ì„ ìœ„í•´ì„œ immutableí•œ ë°°ì—´ í˜¹ì€ ê°ì²´ë¥¼ ì‚¬ìš©í•  í•„ìš”ê°€ ìžˆë‹¤. ì´ë•Œ immutableí•˜ê²Œ ë°°ì—´ í˜¹ì€ ê°ì²´ë¥¼ ê´€ë¦¬í•  ìˆ˜ ìžˆëŠ” ê°€ìž¥ ì¢‹ì€ ìžë£Œêµ¬ì¡°ëŠ” ì–´ë–¤ê±°ë¼ê³  ìƒê°í•˜ì‹œë‚˜ìš”?   íŠ¸ë¼ì´

ê·¸ë ‡ë‹¤ë©´, ë°°ì—´ì˜ ê²½ìš° ìˆ«ìžë¡œ ì¸ë±ì‹±í•´ì„œ ì‚¬ìš©í•˜ë©´ ë˜ì§€ë§Œ, ê°ì²´ì˜ ê²½ìš° key ê°’ì´ ìˆ«ìžê°€ ì•„ë‹Œ ë¬¸ìžì¸ ê²½ìš°ê°€ í›¨ì”¬ ë§Žë‹¤. ì´ë•ŒëŠ” ì–´ë–¤ ì‹ìœ¼ë¡œ íŠ¸ë¼ì´ë¥¼ í™œìš©í•´ì•¼í•˜ë‚˜ìš”? => hashed mapping indexing trie

