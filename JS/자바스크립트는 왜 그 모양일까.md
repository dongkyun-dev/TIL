# 🐳 자바스크립트는 왜 그 모양일까?

> 프로그래밍 언어는 시간이 지날수록 마치 성형 수술 중독으로 인해 고통받는 것 같은 느낌을 받습니다. 프로그래밍 언어의 인기를 계속 유지하기 위해서, 또는 최소한 그럴듯해 보이게 하기 위해서 열심히 새로운 기능들을 집어놓고 있습니다. 비대한 기능은 비대한 코드만큼 아주 크고 본질적인 문제를 가집니다.

---

### 이름에 여러 단어를 사용하는 방법: _(밑줄) vs 카멜케이스

이름에 여러 개의 단어를 사용하는 것도 좋지만, 공백 문자가 허용되지 않아 여러 개의 단어를 어떻게 표기하느냐에 대한 의견이 나뉜다. 한 쪽에서는 각 단어의 첫 번째 문자를 대문자로 표기하는 캐멀 케이스를 써야 한다고 고집하고, 다른 한 쪽에서는 각 단어를 _(밑줄)로 연결해야 한다고 주장한다. 이 논의는 수년간 이어져 왔고, 그 어떤 합의도 이루어지지 않을 것처럼 보인다. 왜냐하면 둘 다 틀렸기 때문이다.

사실 정답은 공백을 사용하는 것이다. 1950년 대에는 컴파일러가 고작 수 킬로워드만 사용해서 동작할 수 있었기 때문에 이름에 공백 문자를 쓰는 것은 너무나 큰 사치였다. 하지만, 현대의 컴파일러는 과거에는 상상도 못할 규모의 일들을 처리하고 있다. 즉, 공백을 사용하여도 전혀 문제가 없는 상황이 되었다. 하지만, 프로그래밍 언어들은 그 뒤로도 이름에 공백 문자를 사용하는 것을 허용하지 않고 있다. 

다음 세대에 등장하게 되는 언어에서는 이름에 공백 사용을 허용하여 가독성을 향상시킬 필요가 있다.

---

### 일반함수의 이름이 소문자로 시작해야만 하는 이유!

자바스크립트의 모든 이름은 반드시 소문자로 시작해야 한다. 이는 자바스크립트의 new 연산자 문제 때문이다.

 자바스크립트의 함수는 일반 함수로 호출될 수도, 생성자 함수로 호출될 수도 있다. 함수를 선언할 때 new 연산자와 함께 생성자 함수로 동작하기를 의도한 함수가 있고, new 연산자 없이 일반 함수로 호출되기를 의도한 함수가 있을 것이다.

이들을 구분하기 위한 약속으로 모든 생성자 함수의 이름은 대문자로 시작하게, 그렇지 않은 모든 경우에는 소문자로 시작되도록 해야 한다. 

---

### 예약어가 꼭 필요한 기능일까?

예약어를 사용하는 것은 메모리가 부족하던 과거에서부터 비롯된 잘못된 기능 중 하나이다. 언어에 예약어를 지정하게 되면 컴파일러의 동작이 좀 더 쉬워지고, 수 바이트를 아낄 수 있었다. 무어의 법칙으로 메모리의 부족은 해소되었지만, 제한된 사고 방식은 그 이후로도 계속되었다.

예약어는 프로그래머 입장에서 분명히 안 좋은 기능이며, 필요하지도 않은 기능이다.

---

### 두 종류의 0

자바스크립트가 사용하는 IEEE 754 표준에는 -0과 0이라는 두 개의 0이 존재한다. 자바스크립트는 이 이상한 현상을 숨기기 위해 열심히 노력했으며, 거의 성공했다, 아래와 같은 경우를 제외하면, -0이 존재한다는 사실을 무시해도 상관없다.

```javascript
(1 / 0) === (1 / -0)     // false
Object.is(0, -0)    // false
```

---

### reduce

Reduce 메서드의 두번째 인자로는 초기값이 들어간다.

만약 초기값을 생략하면 똑똑한 reduce는 배열의 첫번째 원소를 초기값으로 설정하고 첫번째 원소에 대한 연산(reduce의 첫번째 인자로 들어온 수식)을 수행하지 않는다.

---

### reduceRight

배열의 끝에서 시작한다는 것을 제외하면 reduce와 동일하게 동작한다.

---

### 순수 함수와 비순수 함수

순수 함수

> concat, every, filter, find, findIndex, forEach, indexOf, join, lastIndexOf, map, reduce, reduceRight, slice, some

비순수 함수

> fill, splice, pop, push, shift, unshift

순수 함수여야 했던 비순수 함수

> sort, reverse

---

### 객체의 속성 제거하기

```javascript
const obj = {
  a: 1,
  b: 2,
};

// obj라는 객체의 a 속성을 제거하는 두가지 방법
delete obj.a;
delete obj[a];
```

---

### 객체와 관련된 다양한 메서드

- `Object.assign(target, source)` (객체 복사 시에 사용, 타겟 객체에 소스 객체를 복사)

  ```javascript
  const original_obj = {
    a: 1,
    b: 2,
  };
  
  const copied_obj = Object.assign({}, original_obj);  // { a: 1, b: 2 }
  ```

  ```javascript
  const target = { a: 1, b: 2 };
  const source = { b: 4, c: 5 };
  
  const returnedTarget = Object.assign(target, source);
  
  console.log(target);  // Object { a: 1, b: 4, c: 5 }
  console.log(returnedTarget);  // Object { a: 1, b: 4, c: 5 }
  ```

- `Object.create(prototype)` (이미 있는 객체를 전달받아서 이를 상속받는 새로운 객체를 반환. 즉, 객체 상속을 위해 사용)

  ```javascript
  const original_obj = {
    a: 1,
    b: 2,
  };
  
  const inherit_obj = Object.create(original_obj);
  
  console.log(inherit_obj.a);  // 1
  console.log(inherit_obj.b);  // 2
  ```

  > 상속이 있으므로 속성에도 두 가지 형태가 있다는 것을 알 수 있다. 고유 속성, 즉 가장 최근의 객체에만 있는 속성과 상속받은 속성, 즉 프로토타입 체인에 존재하는 속성이다. 때때로 우리는 이 둘을 구분해야 하는 상황에 마주치게 된다. 이때 사용할 수 있는 메서드가 `Object.prototype.hasOwnProperty("속성 이름")`이다.

- `Object.keys(), Object,values(), Object.entries()` (객체 순회를 위해 사용)

- `Object.freeze()` (객체 동결)

---

### Object.prototype.toString()이 가지는 문제

```javascript
const obj = {
  a: 1,
  b: 2,
};

console.log(obj.toString());  // [object Object]
```

내가 기대했던 결과는 `{ a: 1, b: 2 }`였지만 전혀 다른 결과가 나왔다. 이는 `Object.prototype.toString()`이 반환하게 되는 값을 정확히 알지 못해서 저지른 오류이다. 해당 메서드는 `[object type]`을 반환하게 된다. 내가 기대하던 결과를 얻기 위해서는 `JSON.stringify()`를 사용해야 한다.

---

### 객체가 가지는 고유한 문제

> https://ko.javascript.info/prototype-methods

```javascript
const obj = {};

let key = prompt("입력하고자 하는 키는 무엇인가요?", "__proto__");
obj[key] = "어떠한 값";

alert(obj[key]);  // "어떠한 값"이 아닌 [object Object]가 출력된다.
```

이러한 문제가 발생하는 이유는 객체를 리터럴로 선언하는 과정에서 `Object.prototype`이 상속되기 때문이다. 아시다시피 `__proto__`는 객체의 프로퍼티가 아니라 `Object.prototype` 의 접근자 프로퍼티이다.

우리는 이러한 문제를 프로토타입이 없는 객체를 만드는 방법인 `Object.create(null)` 을 사용해서 해결할 수 있다.

```javascript
const obj = Object.create(null);

let key = prompt("입력하고자 하는 키는 무엇인가요?", "__proto__");
obj[key] = "어떠한 값";

alert(obj[key]);  // "어떠한 값"이 제대로 출력된다.
```

---

### Map과 WeakMap의 차이

> https://ui.toast.com/weekly-pick/ko_20210901
>
> 더 깊은 내용은 해당 블로그에서 확인이 가능하다.

WeakMap의 특징을 먼저 정리한다.

- `WeakMap` 객체는 키가 약하게 참조되는 키/값 쌍의 컬렉션으로, 키는 반드시 객체여야만 한다. 원시 값은 키가 될 수 없다. 만약 키를 원시 값으로 추가하면 `Uncaught TypeError: Invalid value used as weak map key`라는 에러가 발생한다.
- 키에 대한 값을 메서드를 통해 확인하는 것은 가능하지만, 키로 보유한 객체들을 열거하는 방법은 존재하지 않는다.
- `WeakMap` 의 키로 쓰인 객체는 가비지 컬렉션 대상이 된다. 

---

### 문자열과 배열의 === 연산자

문자열은 그 값이 같을 경우 === 연산자에 의해 동일하다고 판단된다. 하지만, 배열은 그 값이 같아도 배열이 서로 다르면 다르다.

```javascript
const arr = [1, 2, 3];
console.log(arr === [1, 2, 3]);  // false

const str = 'abc';
console.log(str === 'abc');  // true
```

---

### undefined와 null

어떤 면에서 `null`과 `undefined`는 아주 비슷하다고 볼 수 있지만, 어떤 경우에는 서로 다르게 동작한다. 이들을 언제 어떻게 써야 하는 지를 알아내는 데 많은 시간을 허비하는 것은 비효율적이다. 우리는 이러한 비효율을 개선하기 위해 둘 중 하나만을 써야 한다. 이것이 `null` 대신 `undefined`를 사용하는 이유이다. 

null이 아닌 undefined를 사용하는 이유

- `undefined`는 자바스크립트 스스로가 값으로 사용한다. `let`이나 `var` 구문으로 변수를 정의하고 초기화하지 않으면, 자바스크립트는 묵시적으로 이 변수 값을 `undefined`로 초기화 한다. (물론, `null` 이 전혀 사용되지 않는 것은 아니다. `getElementById` 사용시 해당 id가 존재하지 않는 경우 `null`을 반환한다.)
- `typeof null` 은 `object`를 반환하는 버그를 가지고 있다.

---

### 증감 연산자

++ 나 -- 같은 증감 연산자는 사용하지 않는 것이 좋다. 증감 연산자는 옛날 포인터 연산을 하기 위해 만들어진 연산자이다. 포인터 연산이 아주 위험하다는 사실을 안 뒤로, 최근에 나온 언어에서는 포인터 연산을 더 이상 허용하지 않는다.

1을 더하거나 뺄 때 앞으로는 `+= 1, -= 1`을 사용하도록 한다. 

---

### If-else 보다는 삼항 연산자!

- 삼항 연산자 전체를 괄호로 둘러싸야 한다.
- 여는 괄호 다음에 줄바꿈을 하고 조건문과 조건에 따라 실행할 두 개의 문장을 같은 수준으로 정렬한다.

```javascript
// ex1
const obj = (
	is_mythical
  ? "unicorn"
  : "monster"
);

// ex2
const obj = (
	is_mythical
  ? (
  	is_scary
    ? "monster"
    : "unicorn"
  )
  : (
  	is_insect
    ? "butterfly"
    : "rainbow"
  )
);
```

---

### 단일 문장을 쓸까 블록을 쓸까

```javascript
// case1 단일 문장
if (condition) return 1;

// case2 블록
if (condition) {
  return 1;
}

```

단일의 문장만이 오는 경우 첫번째 케이스가 좋을까, 두번째 케이스가 좋을까?

정답은 항상 두번째 케이스인 블록을 쓰는 것이 더 좋다. 블록을 쓰면 코드를 더 쉽게 개선시킬 수 있기 때문이다. 

---

### 제네레이터

쓰지 않을 것을 권장한다.

책에서 대안으로 제시하는 코드들이 있는데 솔직히 제네레이터에 대해 깊게 이해하지 못한 상태이고, 아직 왜 쓰는 건지를 모르겠다. 언젠가 제네레이터를 쓰는 순간이 온다면 그때 필요에 의한 공부를 해야겠다.

---

### 일반 함수와 생성자 함수

자바스크립트의 모든 함수는 new와 함께 생성자 함수처럼 사용될 수 있다. 이 때문에 언제 어디서 어떤 함수에 new 접두사를 붙여서 호출해야 하는지 바로 알아내는 것은 매우 어렵다. 더 최악인 것은 new 접두사를 써야 하는데도 쓰지 않았을 경우, 아무런 경고도 없다는 것이다.

이를 해결하기 위해 하나의 관습이 생겼다. new 접두사를 써서 호출해야 하는 생성자 함수는 반드시 그 이름을 대문자로 시작해야 한다는 것이다. 다른 함수들은 대문자로 시작해서는 안된다.

---

### argument는 객체로 받자

열개의 인자를 받는 생성자 함수가 있다고 가정한다. 열개의 인자를 각각 변수로 받는다면 추후에 열개 중 하나가 문제가 생겨 변경할 때 어려움이 생기게 된다. 때문에 argument 전체를 하나의 객체로 받고 이를 구조분해할당 하는 것이 좋다.

```javascript
// 안 좋은 방법
function my_little_constructor(name, cost, colors, type, types, text, flavor, power) {
}

// 좋은 방법
function my_little_constructor(spec) {
  const {
    name, cost, colors, type, types, text, flavor, power
  } = spec;
}
```

---

### Date 객체의 `getMonth`와 `getDate`

`getMonth` 메서드는 개발자가 좋아할 만하게, 월의 시작값을 0으로 만든다. 그래서 `getMonth`는 0에서 11 사이의 값을 반환한다.

반면 `getDate` 는 1에서 31 사이의 값을 반환한다.

`getYear` 과 `setYear` 메서드는 1999년도 이후로는 제대로 동작하지 않는다. 때문에 이 둘 대신 `getFullYear` 와 `setFullYear` 를 사용해야 한다.

---

### 자바스크립트 최적화

모든 자그마한 최적화가 나노초 단위로 이득을 보면, 이를 합산했을 때 결국 이득이 된다는 믿음이 있다. 하지만, 이는 사실이 아니다. 괄목할 만한 향상이 있는 최적화만 해야 한다. 그렇지 않은 최적화는 시간 낭비에 불과하다. 최적화의 주요 목적은 시간을 절약하는 것에 있다. 그러므로 우리는 최적화를 최적화할 필요가 있다.

자바스크립트는 최적화가 안 된 느린 코드로 빨리 시작한 다음, 프로그램이 어떻게 동작하느냐에 따라 최적화한다는 복잡한 행동을 취한다.

---

### WAT

자바스크립트의 정확한 동등성 연산자는 === 이다. 올바르지 않은 동등성 연산자인 == 는 쓰면 안된다.

```javascript
"2" < 5  // true
5 < "11"  // true
"11" < "2"  // true
```

> 문자와 숫자를 비교하면 숫자로의 타입 변경이 강제된다. 
>
> 문자와 문자를 비교하는 경우에는 아스키 코드를 기준으로 비교하게 된다.

```javascript
1 < 2 < 3  // true
3 > 2 > 1  // false
```

> 이 경우는 문법적 에러라고 봐야 한다. 첫 번째 경우에서 1과 2를 비교한 것은 true라는 결과를 낸다. 그리고 true와 3을 비교하게 된다. true는 1로 강제되며, 1은 3보다 작기 때문에 true가 된다.
>
> 두 번째 경우에서는 3과 2를 비교해서 true가 나온다. true와 1이 비교되면, true는 1로 강제되고 1은 1보다 작지 않기 때문에 false가 된다.

```javascript
"2" + 1  // "21"
"2" - 1  // 1
```

> 다른 산술 연산자들도 타입 강제를 적용하지만, + 연산자와는 다른 규칙을 사용한다.

전역 `isNan` 함수와 `isFinite` 함수는 잘못된 함수이다. 그 대신 `Number.isNan`와 `Number.isFinite`를 사용해야 한다.

자동 세미콜론 삽입 기능은 기능이 아니다. 오히려 위험이다. 어디에 세미콜론을 넣어야 할지 확실히 모르는 초급자를 위해 특별히 추가된 언어 기능이다.



