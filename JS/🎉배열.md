# 🎉배열

---

> 모던 자바스크립트 Deep Dive 27장 배열에서 중요하다고 생각이 드는 부분들을 정리한다.

---

자바스크립트에는 배열이라는 타입이 존재하지 않는다. 배열은 객체 타입이다.

배열은 객체이지만, 일반 객체와는 구별되는 독특한 특징이 있다.

|      구분       |           객체            |     배열      |
| :-------------: | :-----------------------: | :-----------: |
|      구조       | 프로퍼티 키와 프로퍼티 값 | 인덱스와 요소 |
|    값의 참조    |        프로퍼티 키        |    인덱스     |
|    값의 순서    |             X             |       O       |
| length 프로퍼티 |             X             |       O       |

일반 객체와 배열을 구분하는 가장 명확한 차이는 "값의 순서"와 "length 프로퍼티" 이다. 

---

자바스크립트의 배열은 지금까지 살펴본 자료구조에서 말하는 일반적인 의미의 배열과는 다르다. 즉, 배열의 요소를 위한 각각의 메모리 공간은 동일한 크기를 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있다. 배열의 요소가 연속적으로 이어져 있지 않는 배열을 **희소 배열(sparse array)**이라 하며, 자바스크립트의 배열이 그러하다.

때문에 자바스크립트의 배열은 엄밀히 말해 일반적 의미의 배열이 아니다. 자바스크립트의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체이다.

일반적인 배열과 자바스크립트 배열의 장단점을 정리해보면 다음과 같다.

- 일반적인 배열은 인덱스로 요소에 빠르게 접근할 수 있다. 하지만, 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우에는 효율적이지 않다.
- 자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 요소에 접근하는 경우 일반적인 배열보다 성능적인 면에서 느릴 수 밖에 없는 구조적인 단점이 있다. 하지만, 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.

인덱스로 배열 요소에 접근할 때, 일반적인 배열보다 느릴 수 밖에 없는 구조적인 단점을 보완하기 위해 대부분의 모던 자바스크립트 엔진은 배열을 일반 객체와 구별하여 좀 더 배열처럼 동작하도록 최적화하여 구현했다.

```javascript
const arr = []

for(let i = 0; i < 10000000; i++) {
	arr[i] = i 
}
// 약 340ms

const obj = {}

for(let i = 0; i < 10000000; i++) {
	obj[i] = i
}
// 약 600ms
```

 그런데 실제 알고리즘 문제를 풀다보면 key값이 문자열인 배열 혹은 객체를 만드는 일이 종종 있다. 그렇다면, 이런 일반적이지 않은 배열에서는 어떤 것이 더 빠를까?

실제 벤치마크를 돌려보니 둘 다 비슷하다. 아무래도 둘다 해시 테이블을 통해 접근해야하다보니 그러한 것 같다. 

때문에, key값이 문자열이라면 빈 배열보다는 빈 객체에 저장하는 것이 훨씬 직관적이고 좋은 선택지가 될 것 같다.

---

자바스크립트에서 length 프로퍼티의 값은 0과 2^32 - 1 미만의 양의 정수다. 즉, 배열은 요소를 최대 2^32 - 1개 가질 수 있다. 따라서 배열에서 사용할 수 있는 가장 작은 인덱스는 0이며, 가장 큰 인덱스는 2^32 - 2다.

---

자바스크립트의 배열은 위에서 봤다싶이 희소배열이다. 하지만, 희소배열이 될 수 있다는 것이지 희소배열로 사용하는 것을 추천한다는 말은 아니다. 가장 높은 성능의 배열을 사용하기 위해서는 같은 타입의 요소를 연속적으로 위치시키는 것이 최선이다.

---

`const arr = []` 이런 식으로 선언하는 것을 배열 리터럴이라 한다. 

`new Array()`와 같은 생성자로도 빈 배열을 생성할 수 있다. 하지만, 이때 주의해야할 것이 있다. 생성자로 배열을 생성하는 방식은 아예 전달된 인수가 없거나, 2개 이상의 숫자를 인수로 받거나, 숫자가 아닌 타입의 인수를 받아야 한다. 

즉, 숫자 한 개를 인수로 받는 경우에는 생성자로 배열을 생성할 수 없다.

```javascript
new Array()    // []
new Array(1, 2)    // [1, 2]
new Array({})    // [{}]

new Array(1)    // 불가능!!!
```

---

그렇다면 숫자 한 개를 인수로 받아야 하는 경우에는 어떻게 배열을 만들 수 있을까?

바로 ES6에서 도입된 `Array.of` 메서드를 사용하면 된다.

```javascript
Array.of(1)    // [1]
Array.of(1, 2, 3)    // [1, 2, 3]
Array.of('string')    // ['string']
```

---

## Array.from

ES6에서 도입된 Array.from 메서드는 유사 배열 객체 또는 이터러블 객체를 인수로 전달받아 배열로 변환하여 반환한다.

유사 배열 객체와 이터러블 객체의 차이는 무엇일까?

유사 배열 객체는 마치 배열처럼 인덱스로 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.

```javascript
const arraylike = {
	'0': 'apple',
	'1': 'banana',
	'2': 'orange',
	length: 3
}
```

이터러블 객체는 Symbol.iterator 메서드를 구현하여 for ... of 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있는 객체를 말한다. ES6에서 제공하는 빌트인 이터러블은 Array, String, Map, Set, DOM 컬렉션(NodeList, HTMLCollection), arguments 등이 있다.

유사 배열이면 이터러블 객체가 아니고, 이터러블 객체면 유사 배열이 아니고와 같이 이 두 가지 개념이 대칭적인 의미를 가지는 것은 아니다. arguments 객체의 경우 유사 배열 객체이면서 이터러블 객체이다. 즉, 각각이 가져야하는 특징을 모두 만족한다면 양 종류가 모두가 될 수 있다. (정확하지는 않지만, DOM 컬렉션도 유사 배열이면서 이터러블 객체인 것으로 기억한다.)

실제 사용 예제를 보자.

```javascript
Array.from({ length: 2, 0: 'a', 1: 'b' })    // ['a', 'b']

Array.from('Hello')    // ['H', 'e', 'l', 'l', 'o']

Array.from({ length: 3 })    // [undefined, undefined, undefined]

Array.from({ length: 3 }, (value, index) => index)    // [0, 1, 2]
```

맨 마지막 예제는 잘 알지도 못하면서 굉장히 많이 사용했던 모양이다. 항상 알고리즘 문제를 풀 때 2차원 배열이 필요하게 되면 `Array.from(new Array(3), ()=>new Array(3))` 이런 식의 코드로 3 * 3 배열을 만들어서 사용해 왔다. 이런 식의 코드가 이차원 배열을 어떻게 만드는지 이해하기 위해서는 `Array.from`의 기본 인자를 확인할 필요가 있다.

```javascript
Array.from(arrayLike[, mapFn[, thisArg]])
```

`Array.from()`은 첫번째 인자로 유사배열 혹은 이터러블 객체를 받고, 두번째 인자로 받는 map 함수를 통해 해당 유사배열 혹은 이터러블 객체를 순회할 수 있다.

때문에 위와 같은 코드로 이차원 배열을 만들어서 사용할 수 있었던 것이다.

---

자바스크립트 배열에서는 존재하지 않는 요소에 접근하게 되면 에러가 나는 것이 아니라, undefined 가 반환된다. (알고리즘을 풀 때는 이러한 자바스크립트의 특징이 굉장히 유용할 때가 많다.)

---

배열에서 특정한 원소의 index가 필요할 때는 `indexOf()`, 배열 안에 특정한 원소가 존재하는지만을 검사할 때는 `includes()`를 사용한다. 

`indexOf()`의 반환값은 특정한 원소가 존재하는 경우 그 원소의 첫번째로 나오는 인덱스, 존재하지 않는 경우 -1을 반환한다. 두번째 인수를 사용하여 득정한 지점에서부터 검색이 가능하다.

`includes()`의 반환값은 true 혹은 false 이다.

특정한 조건을 만족하는 원소를 가져와야 할 때는 `find()`메서드를 쓴다. 조건에 맞는 원소가 존재한다면 조건에 맞는 가장 첫번째 원소를 반환하고 없다면 undefined를 반환한다.

```javascript
users.find(user => user.id === 2)
```



---

push 메서드는 성능 면에서 좋지 않다. 마지막 요소로 추가할 요소가 하나뿐이라면 push 메서드를 사용하지 않고 length 프로퍼티를 사용하여 배열의 마지막에 요소를 직접 추가할 수도 있다.

```javascript
const arr = [1, 2]

arr[arr.length] = 3
console.log(arr)    // [1, 2, 3]
```

---

유사 배열 객체 혹은 이터러블 객체를 배열로 변환하는 방법은 크게 두가지가 존재한다.

```javascript
const arr = Array.prototype.slice.call(arguments)

const arr = Array.from(arguments)

// 이터러블 객체의 경우에는 스프레드 연산자를 통해 더 쉽게 배열로 만들 수 있다.
const arr = [...arguments]
```

---

### sort 메서드

sort 메서드는 quicksort 알고리즘을 사용했었다. quicksort 알고리즘은 동일한 값의 요소가 중복되어 있을 때 초기 순서와 변경될 수 있는 불안정한 정렬 알고리즘으로 알려져 있다. ES10부터는 timesort 알고리즘을 사용한다.

항상 어떠한 기준을 가지고 sort해야 할 때 다음과 같은 식으로 코드를 작성해왔다.

```javascript
arr.sort((a, b) => {
	if (a['id'] > b['id']) return 1
	else if (a['id'] < b['id']) return -1
	else return 0
})
```

하지만, 훨씬 함수형스럽고 간단한 코드가 있다.

```javascript
arr.sort(compare('id'))

function compare(key) {
	return (a, b) => (a[key] > b[key] ? 1 : (a[key] < b[key] ? -1 : 0))
}
```

이런 식으로 코드를 작성하면 재사용성과 다형성 측면에서 굉장히 효율적인 코드가 된다. 또한 , if-elseif-else 구문을 저렇게 한 줄로 간단하게 표현할 수 있다는 것을 기억해둘 필요가 있겠다.

---

forEach 메서드는 for 문과는 달리 break, continue, return문을 사용할 수 없다. 다시 말해, 배열의 모든 요소를 빠짐없이 모두 순회하며 중간에 순회를 중단할 수 없다.

forEach 메서드는 for 문에 비해 성능이 좋지는 않지만 가독성은 더 좋다. 따라서 요소가 대단히 많은 배열을 순회하거나 시간이 많이 걸리는 복잡한 코드 또는 높은 성능이 필요한 경우가 아니라면 for 문 대신 forEach 메서드를 사용할 것을 권장한다.
